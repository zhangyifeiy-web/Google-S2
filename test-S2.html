<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Google S2 可视化 - 标准校正版</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">

  <style>
    body { margin: 0; background-color: #000; overflow: hidden; font-family: 'Noto Sans SC', 'Orbitron', sans-serif; color: #00ff99; }
    #hud-container {
      position: absolute; top: 20px; left: 20px; width: 360px;
      background: rgba(5, 10, 15, 0.9); border: 1px solid #00ffff; border-radius: 8px; padding: 20px;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.2); backdrop-filter: blur(5px); z-index: 10; max-height: 95vh; overflow-y: auto;
    }
    #hud-container::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 2px; background: linear-gradient(90deg, #00ffff, #00ff99); }
    h2 { font-family: 'Orbitron', sans-serif; margin: 0 0 15px 0; font-size: 20px; color: #fff; text-align: center; text-shadow: 0 0 10px rgba(0, 255, 255, 0.5); }
    .control-group { margin-bottom: 12px; }
    label { display: block; font-size: 12px; color: #888; margin-bottom: 4px; }
    input[type="number"], input[type="text"] {
      width: 100%; background: rgba(0, 0, 0, 0.6); border: 1px solid #333; color: #00ff99; padding: 6px; font-family: 'Orbitron', sans-serif; font-size: 14px; border-radius: 4px; box-sizing: border-box;
    }
    input:focus { outline: none; border-color: #00ffff; }
    .mode-switcher { display: flex; background: rgba(0,0,0,0.5); border-radius: 4px; margin-bottom: 10px; border: 1px solid #333; }
    .mode-btn { flex: 1; background: transparent; border: none; color: #888; padding: 8px 0; font-size: 12px; cursor: pointer; border-right: 1px solid #333; }
    .mode-btn:last-child { border-right: none; }
    .mode-btn.active { background: rgba(0, 255, 255, 0.2); color: #00ffff; }
    .btn-row { display: flex; gap: 10px; margin-top: 10px; }
    button { flex: 1; background: rgba(0, 255, 255, 0.1); border: 1px solid #00ffff; color: #00ffff; padding: 8px; cursor: pointer; font-size: 13px; font-weight: bold; }
    button:hover { background: #00ffff; color: #000; box-shadow: 0 0 10px rgba(0, 255, 255, 0.5); }
    button.secondary { border-color: #ff0055; color: #ff0055; background: rgba(255, 0, 85, 0.1); }
    button.secondary:hover { background: #ff0055; color: white; }
    .divider { height: 1px; background: #333; margin: 15px 0; }
    #output-panel { margin-top: 15px; border-top: 1px solid #333; padding-top: 10px; }
    .data-row { display: flex; justify-content: space-between; margin-bottom: 6px; font-size: 13px; align-items: center;}
    .data-label { color: #888; }
    .data-value { color: #fff; font-family: 'Orbitron', monospace; text-align: right; word-break: break-all; max-width: 65%; }
    .highlight { color: #00ff99; }
    .toggle-row { display: flex; align-items: center; margin-top: 5px; font-size: 13px; cursor: pointer; color: #ccc; }
    .toggle-row input { margin-right: 8px; width: auto; }
    .tip { font-size: 11px; color: #555; margin-top: 4px; font-style: italic; }
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: #000; }
    ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
  </style>
</head>
<body>

<div id="hud-container">
  <h2>S2 索引 (Fixed)</h2>

  <div class="control-group">
    <label>视图模式</label>
    <div class="mode-switcher">
      <button class="mode-btn active" onclick="setMode(0)">球体</button>
      <button class="mode-btn" onclick="setMode(1)">立方体</button>
      <button class="mode-btn" onclick="setMode(2)">平面展开</button>
    </div>
    <div class="tip" id="mode-tip">标准地球视图</div>
  </div>

  <div class="control-group">
    <label>纬度 (Lat)</label>
    <input type="number" id="lat" value="39.90499" step="0.0001">
  </div>
  <div class="control-group">
    <label>经度 (Lng)</label>
    <input type="number" id="lng" value="116.39797" step="0.0001">
  </div>
  <div class="control-group">
    <label>网格层级 (Level 0-20)</label>
    <input type="number" id="level" value="18" min="0" max="20">
  </div>

  <div class="toggle-row">
    <input type="checkbox" id="autoRotate" checked>
    <label for="autoRotate">自动旋转</label>
  </div>
  <div class="toggle-row">
    <input type="checkbox" id="showParents" checked>
    <label for="showParents">显示父级网格</label>
  </div>
  <div class="toggle-row">
    <input type="checkbox" id="showHilbert" checked>
    <label for="showHilbert" style="color:#ffaa00">显示希尔伯特曲线</label>
  </div>

  <div class="btn-row">
    <button onclick="updateVisualization()">生成 & 定位</button>
    <button class="secondary" onclick="resetCamera()">重置视角</button>
  </div>

  <div class="divider"></div>

  <div class="control-group">
    <label>反向查询 (支持 Token 或 ID)</label>
    <div style="display: flex; gap: 5px;">
      <input type="text" id="query-cellid" placeholder="如 35f052be77">
      <button style="flex: 0 0 60px;" onclick="reverseQuery()">查询</button>
    </div>
    <div class="tip" id="query-msg" style="color:#ff0055; display:none;">无效的 ID</div>
  </div>

  <div id="output-panel">
    <div class="data-row">
      <span class="data-label">Face ID</span>
      <span class="data-value" id="out-face">-</span>
    </div>
    <div class="data-row">
      <span class="data-label">Level</span>
      <span class="data-value" id="out-level">-</span>
    </div>
    <div class="data-row">
      <span class="data-label">QuadKey</span>
      <span class="data-value highlight" id="out-token">-</span>
    </div>
    <div class="data-row" style="align-items: flex-start; margin-top: 8px;">
      <span class="data-label">Cell ID (Int64)</span>
    </div>
    <div class="data-row">
      <span class="data-value" id="out-cellid" style="color:#ffaa00; font-size:12px; max-width:100%; text-align:left;">-</span>
    </div>
  </div>
</div>

<script>
  // ==========================================
  // S2 核心算法 (含 Face 1 修正)
  // ==========================================
  const SimpleS2 = {
    latLngToXYZ: function(lat, lng) {
      const phi = (lat * Math.PI) / 180;
      const theta = (lng * Math.PI) / 180;
      const cosPhi = Math.cos(phi);
      return { x: cosPhi * Math.cos(theta), y: cosPhi * Math.sin(theta), z: Math.sin(phi) };
    },
    xyzToFaceUV: function(x, y, z) {
      let face = 0;
      const absX = Math.abs(x), absY = Math.abs(y), absZ = Math.abs(z);
      if (absX >= absY && absX >= absZ) face = x > 0 ? 0 : 3;
      else if (absY >= absX && absY >= absZ) face = y > 0 ? 1 : 4;
      else face = z > 0 ? 2 : 5;
      let u=0, v=0;
      switch(face) {
        case 0: u = y/x; v = z/x; break; case 1: u = -x/y; v = z/y; break; case 2: u = -x/z; v = -y/z; break;
        case 3: u = z/x; v = y/x; break; case 4: u = z/y; v = -x/y; break; case 5: u = -y/z; v = -x/z; break;
      }
      return { face, u, v };
    },
    uvToST: function(u, v) { return { s: 0.5 * (u + 1), t: 0.5 * (v + 1) }; },
    faceUVToXYZ: function(face, u, v) {
      let x, y, z;
      switch(face) {
        case 0: x = 1; y = u; z = v; break; case 1: x = -u; y = 1; z = v; break; case 2: x = -u; y = -v; z = 1; break;
        case 3: x = -1; y = -v; z = -u; break; case 4: x = v; y = -1; z = -u; break; case 5: x = v; y = u; z = -1; break;
      }
      const len = Math.sqrt(x*x + y*y + z*z);
      return { x: x/len, y: y/len, z: z/len };
    },
    getCell: function(lat, lng, level) {
      const p = this.latLngToXYZ(lat, lng);
      const fuv = this.xyzToFaceUV(p.x, p.y, p.z);
      const st = this.uvToST(fuv.u, fuv.v);
      const n = Math.pow(2, level);
      const i = Math.floor(st.s * n);
      const j = Math.floor(st.t * n);
      return { face: fuv.face, level: level, i: Math.max(0, Math.min(n-1, i)), j: Math.max(0, Math.min(n-1, j)), n: n };
    },
    getQuadKey: function(cell) {
      let key = "";
      for(let l = 1; l <= cell.level; l++) {
        const mask = 1 << (cell.level - l);
        key += (((cell.i & mask)?1:0) + ((cell.j & mask)?2:0)).toString();
      }
      return key;
    },
    ijToHilbert: function(n, i, j) {
      let d = 0n, s = BigInt(Math.floor(n / 2)), bi = BigInt(i), bj = BigInt(j);
      while (s > 0n) {
        let rx = (bi & s) > 0n ? 1n : 0n, ry = (bj & s) > 0n ? 1n : 0n;
        d += s * s * ((3n * rx) ^ ry);
        if (ry === 0n) {
          if (rx === 1n) { bi = (2n * s) - 1n - bi; bj = (2n * s) - 1n - bj; }
          let t = bi; bi = bj; bj = t;
        }
        s /= 2n;
      }
      return d;
    },
    hilbertToIJ: function(n, d) {
      let i = 0n, j = 0n, t = BigInt(d), s = 1n, bigN = BigInt(n);
      while (s < bigN) {
        let rx = 1n & (t / 2n), ry = 1n & (t ^ rx);
        if (ry === 0n) {
          if (rx === 1n) { i = s - 1n - i; j = s - 1n - j; }
          let temp = i; i = j; j = temp;
        }
        i += s * rx; j += s * ry; t /= 4n; s *= 2n;
      }
      return { i: Number(i), j: Number(j) };
    },

    // --- 核心修复：坐标交换逻辑 ---
    // Google S2 在 Face 1 (奇数面) 上会交换 i 和 j 轴

    getCellId: function(cell) {
      const faceBi = BigInt(cell.face);
      let i = cell.i, j = cell.j;

      // 修复：如果是奇数 Face，交换 IJ
      if (cell.face % 2 !== 0) {
        let temp = i; i = j; j = temp;
      }

      const posL = this.ijToHilbert(cell.n, i, j);
      const shift = BigInt(60 - 2 * cell.level);
      return (faceBi << 61n) | (posL << (shift + 1n)) | (1n << shift);
    },

    idToCellInfo: function(inputStr) {
      try {
        let id;
        let str = inputStr.trim().replace(/^0x/i, '');
        const isHex = /[a-fA-F]/.test(str);
        const isShort = str.length <= 16;
        if (isHex || isShort) {
          while (str.length < 16) str += '0';
          id = BigInt('0x' + str);
        } else {
          id = BigInt(str);
        }

        let lsb = 0n;
        while ((id & (1n << lsb)) === 0n && lsb < 64n) lsb++;
        if (lsb > 60n) return null;

        const levelBig = (60n - lsb) / 2n;
        const level = Number(levelBig);
        const face = Number(id >> 61n);
        const shift = lsb + 1n;
        const indexMask = (1n << (levelBig * 2n)) - 1n;
        const hilbertIndex = (id >> shift) & indexMask;

        const n = Math.pow(2, level);
        let ij = this.hilbertToIJ(n, hilbertIndex);
        let i = ij.i, j = ij.j;

        // 修复：如果是奇数 Face，交换回 IJ
        if (face % 2 !== 0) {
          let temp = i; i = j; j = temp;
        }

        const s = (i + 0.5) / n;
        const t = (j + 0.5) / n;
        const u = 2 * s - 1;
        const v = 2 * t - 1;
        const p = this.faceUVToXYZ(face, u, v);
        const r = Math.sqrt(p.x*p.x + p.y*p.y + p.z*p.z);

        return {
          lat: Math.asin(p.z / r) * (180 / Math.PI),
          lng: Math.atan2(p.y, p.x) * (180 / Math.PI),
          level, face, parsedId: id
        };
      } catch (e) { console.error(e); return null; }
    }
  };

  // ==========================================
  // Three.js (无变化)
  // ==========================================
  let scene, camera, renderer, controls;
  let earthGroup = new THREE.Group(), cellGroup = new THREE.Group(), hilbertGroup = new THREE.Group();
  let targetPointMesh;
  let currentMode = 0;
  let morphFactors = { sphereToCube: 0, cubeToUnfold: 0 };
  const UNFOLD_OFFSET = 2.05;

  window.onload = init;

  function init() {
    scene = new THREE.Scene(); scene.background = new THREE.Color(0x020205); scene.fog = new THREE.FogExp2(0x020205, 0.02);
    camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.01, 1000); camera.position.set(0, 0, 5);
    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement);
    controls = new THREE.OrbitControls(camera, renderer.domElement); controls.enableDamping = true; controls.autoRotate = true;

    createMorphEarth(); createStars();
    scene.add(cellGroup); scene.add(hilbertGroup);

    const pointGeo = new THREE.SphereGeometry(0.03, 16, 16);
    targetPointMesh = new THREE.Mesh(pointGeo, new THREE.MeshBasicMaterial({ color: 0xff0055 }));
    scene.add(targetPointMesh);

    // 默认执行一次反向查询，自动验证 35f052be77
    document.getElementById('query-cellid').value = "35f052be77";
    reverseQuery();

    animate();
    window.addEventListener('resize', onWindowResize, false);

    const autoRotateCheckbox = document.getElementById('autoRotate');
    autoRotateCheckbox.addEventListener('change', (e) => { controls.autoRotate = e.target.checked; });
    document.querySelectorAll('input').forEach(input => {
      input.addEventListener('focus', () => { controls.autoRotate = false; });
      input.addEventListener('blur', () => { if(autoRotateCheckbox.checked) controls.autoRotate = true; });
    });
  }

  function reverseQuery() {
    const val = document.getElementById('query-cellid').value.trim();
    if (!val) return;
    const result = SimpleS2.idToCellInfo(val);

    if (result) {
      document.getElementById('query-msg').style.display = 'none';
      document.getElementById('lat').value = result.lat.toFixed(5);
      document.getElementById('lng').value = result.lng.toFixed(5);

      let safeLevel = result.level > 20 ? 20 : result.level;
      if (result.level > 20) alert(`层级 ${result.level} 过高，可视化限制为 20。`);
      document.getElementById('level').value = safeLevel;

      updateVisualization();

      if (document.getElementById('autoRotate').checked) {
        controls.autoRotate = false;
        document.getElementById('autoRotate').checked = false;
      }
    } else {
      document.getElementById('query-msg').style.display = 'block';
    }
  }

  function createMorphEarth() {
    scene.add(earthGroup);
    const faceColors = [0x0088ff, 0x00ff88, 0xff8800, 0x004488, 0x008844, 0x884400];
    for(let f=0; f<6; f++) {
      const g = new THREE.PlaneGeometry(2, 2, 32, 32);
      const m = new THREE.MeshBasicMaterial({ color: faceColors[f], wireframe: true, transparent: true, opacity: 0.1, side: THREE.DoubleSide });
      const mesh = new THREE.Mesh(g, m); mesh.userData = { faceIndex: f };
      const pos = g.attributes.position; const orig = [];
      for(let i=0; i<pos.count; i++) orig.push({ u: pos.getX(i), v: pos.getY(i) });
      mesh.userData.originalPositions = orig; earthGroup.add(mesh);
    }
  }
  function createStars() {
    const geo = new THREE.BufferGeometry(), verts = [];
    for(let i=0; i<2000; i++) verts.push(THREE.MathUtils.randFloatSpread(80), THREE.MathUtils.randFloatSpread(80), THREE.MathUtils.randFloatSpread(80));
    geo.setAttribute('position', new THREE.Float32BufferAttribute(verts, 3));
    scene.add(new THREE.Points(geo, new THREE.PointsMaterial({color: 0x888888, size: 0.05})));
  }
  function getMorphedPoint(face, u, v) {
    const sP = SimpleS2.faceUVToXYZ(face, u, v);
    const vecSphere = new THREE.Vector3(sP.x, sP.y, sP.z);
    let cX, cY, cZ;
    switch(face) {
      case 0: cX=1; cY=u; cZ=v; break; case 1: cX=-u; cY=1; cZ=v; break; case 2: cX=-u; cY=-v; cZ=1; break;
      case 3: cX=-1; cY=-v; cZ=-u; break; case 4: cX=v; cY=-1; cZ=-u; break; case 5: cX=v; cY=u; cZ=-1; break;
    }
    const vecCube = new THREE.Vector3(cX, cY, cZ);
    let ufX=0, ufY=0; const S = UNFOLD_OFFSET;
    if(face===1) ufX=-S; else if(face===4) ufX=S; else if(face===2) ufY=S; else if(face===5) ufY=-S; else if(face===3) ufX=S*2;
    const vecUnfold = new THREE.Vector3(ufX + u, ufY + v, 0);
    const p1 = new THREE.Vector3().lerpVectors(vecSphere, vecCube, morphFactors.sphereToCube);
    const pFinal = new THREE.Vector3().lerpVectors(p1, vecUnfold, morphFactors.cubeToUnfold);
    return { x: pFinal.x, y: pFinal.z, z: -pFinal.y };
  }
  function updateVisualization() {
    while(cellGroup.children.length > 0) cellGroup.remove(cellGroup.children[0]);
    while(hilbertGroup.children.length > 0) hilbertGroup.remove(hilbertGroup.children[0]);
    const lat = parseFloat(document.getElementById('lat').value);
    const lng = parseFloat(document.getElementById('lng').value);
    let level = parseInt(document.getElementById('level').value);
    const showParents = document.getElementById('showParents').checked;
    const showHilbert = document.getElementById('showHilbert').checked;
    if(level < 0) level = 0; if(level > 20) level = 20;
    const targetCell = SimpleS2.getCell(lat, lng, level);
    document.getElementById('out-token').innerText = SimpleS2.getQuadKey(targetCell);
    document.getElementById('out-face').innerText = targetCell.face;
    document.getElementById('out-level').innerText = targetCell.level;
    document.getElementById('out-cellid').innerText = SimpleS2.getCellId(targetCell).toString() + " (BigInt)";

    const p = SimpleS2.latLngToXYZ(lat, lng);
    const fuv = SimpleS2.xyzToFaceUV(p.x, p.y, p.z);
    targetPointMesh.userData.s2 = { face: fuv.face, u: fuv.u, v: fuv.v };

    const levels = showParents ? Array.from({length: level + 1}, (_, i) => i) : [level];
    levels.forEach(lvl => { createCellMesh(SimpleS2.getCell(lat, lng, lvl), lvl === level); });
    if (showHilbert) createHilbertCurve(targetCell.face, level <= 6 ? level : 5);
    if (currentMode === 2) moveCameraToFace(targetCell.face);
  }
  function createCellMesh(cell, isTarget) {
    const step = 1 / cell.n, s0 = cell.i * step, s1 = (cell.i + 1) * step, t0 = cell.j * step, t1 = (cell.j + 1) * step;
    const corners = [{u: 2*s0-1, v: 2*t0-1}, {u: 2*s0-1, v: 2*t1-1}, {u: 2*s1-1, v: 2*t1-1}, {u: 2*s1-1, v: 2*t0-1}];
    const lineGeo = new THREE.BufferGeometry(), linePos = new Float32Array(5 * 3);
    lineGeo.setAttribute('position', new THREE.BufferAttribute(linePos, 3));
    const line = new THREE.Line(lineGeo, new THREE.LineBasicMaterial({ color: isTarget ? 0x00ff99 : 0x0055aa, transparent: true, opacity: isTarget?1:0.3 }));
    line.userData = { type: 'cellLine', face: cell.face, corners, level: cell.level }; cellGroup.add(line);
    if (isTarget) {
      const meshGeo = new THREE.BufferGeometry(), meshPos = new Float32Array(6 * 3);
      meshGeo.setAttribute('position', new THREE.BufferAttribute(meshPos, 3));
      const mesh = new THREE.Mesh(meshGeo, new THREE.MeshBasicMaterial({ color: 0x00ff99, transparent: true, opacity: 0.2, side: THREE.DoubleSide }));
      mesh.userData = { type: 'cellMesh', face: cell.face, corners }; cellGroup.add(mesh);
    }
  }
  function createHilbertCurve(face, level) {
    const n = Math.pow(2, level), totalPoints = n * n, pointsData = [], step = 1/n;
    for (let d = 0; d < totalPoints; d++) {
      let ij = SimpleS2.hilbertToIJ(n, d);
      // 可视化时，希尔伯特曲线的连接顺序也需要根据 face 调整
      // 但这里我们只画几何位置，位置坐标由 getMorphedPoint 决定，
      // 而 getMorphedPoint 的 u,v 是物理坐标。
      // 我们需要知道 d 对应的物理 (u,v) 是什么。
      // hilbertToIJ(d) 得到的是 逻辑IJ。
      // 如果是奇数面，逻辑IJ 和 物理IJ 是 swap 的。
      let i = ij.i, j = ij.j;
      if (face % 2 !== 0) { let t=i; i=j; j=t; }

      pointsData.push({ u: 2*((i + 0.5) * step)-1, v: 2*((j + 0.5) * step)-1 });
    }
    const geo = new THREE.BufferGeometry(), pos = new Float32Array(totalPoints * 3);
    geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    const line = new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.6 }));
    line.userData = { type: 'hilbert', face: face, points: pointsData }; hilbertGroup.add(line);
  }
  function updateOverlayPositions() {
    if (targetPointMesh.userData.s2) {
      const d = targetPointMesh.userData.s2, p = getMorphedPoint(d.face, d.u, d.v), off = (currentMode === 0) ? 1.01 : 0.05;
      targetPointMesh.position.set(currentMode===0?p.x*off:p.x, currentMode===0?p.y*off:p.y+off, currentMode===0?p.z*off:p.z);
      if(currentMode===0) targetPointMesh.lookAt(0,0,0); else targetPointMesh.rotation.set(0,0,0);
    }
    const updateChild = (child, hOffset) => {
      if (!child.userData.corners && !child.userData.points) return;
      const posArr = child.geometry.attributes.position.array;
      const data = child.userData.corners || child.userData.points;
      const isLine = child.userData.type === 'cellLine';
      const mapPt = (pt) => {
        const mp = getMorphedPoint(child.userData.face, pt.u, pt.v);
        return currentMode===0 ? {x:mp.x*(1+hOffset), y:mp.y*(1+hOffset), z:mp.z*(1+hOffset)} : {x:mp.x, y:mp.y+hOffset, z:mp.z};
      };
      if (child.userData.corners) {
        const mapped = data.map(mapPt);
        const indices = isLine ? [0,1,2,3,0] : [0,1,2, 0,2,3];
        for(let i=0; i<indices.length; i++) {
          const p = mapped[indices[i]];
          posArr[i*3] = p.x; posArr[i*3+1] = p.y; posArr[i*3+2] = p.z;
        }
      } else {
        for(let i=0; i<data.length; i++) {
          const p = mapPt(data[i]);
          posArr[i*3] = p.x; posArr[i*3+1] = p.y; posArr[i*3+2] = p.z;
        }
      }
      child.geometry.attributes.position.needsUpdate = true;
    };
    cellGroup.children.forEach(c => updateChild(c, (currentMode===0?(0.005+c.userData.level*0.002):0.02)));
    hilbertGroup.children.forEach(c => updateChild(c, (currentMode===0?0.002:0.01)));
    earthGroup.children.forEach(m => {
      const pos = m.geometry.attributes.position, orig = m.userData.originalPositions;
      for(let i=0; i<pos.count; i++) { const p = getMorphedPoint(m.userData.faceIndex, orig[i].u, orig[i].v); pos.setXYZ(i, p.x, p.y, p.z); }
      pos.needsUpdate = true;
    });
  }
  function animate() {
    requestAnimationFrame(animate); controls.update();
    morphFactors.sphereToCube += ((currentMode>=1?1:0) - morphFactors.sphereToCube)*0.05;
    morphFactors.cubeToUnfold += ((currentMode===2?1:0) - morphFactors.cubeToUnfold)*0.05;
    updateOverlayPositions(); renderer.render(scene, camera);
  }
  function setMode(m) {
    currentMode = m;
    document.querySelectorAll('.mode-btn').forEach((b,i)=> b.classList.toggle('active', i===m));
    document.getElementById('mode-tip').innerText = ["球体投影：真实地理关系", "立方体投影：S2 的数学基础", "希尔伯特展开：一维索引生成的平面"][m];
    controls.autoRotate = (m!==2) && document.getElementById('autoRotate').checked;
  }
  function moveCameraToFace(face) {
    const c = getMorphedPoint(face, 0, 0), startP = camera.position.clone(), startT = controls.target.clone();
    const endT = new THREE.Vector3(c.x, c.y, c.z), endP = new THREE.Vector3(c.x, c.y+4, c.z);
    let t = 0;
    (function tw() {
      t += 0.03; if(t>1)t=1; const e = 1 - Math.pow(1-t, 3);
      camera.position.lerpVectors(startP, endP, e); controls.target.lerpVectors(startT, endT, e);
      if(t<1) requestAnimationFrame(tw);
    })();
  }
  function resetCamera() { camera.position.set(0, 0, 5); controls.target.set(0, 0, 0); }
  function onWindowResize() { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
</script>
</body>
</html>
